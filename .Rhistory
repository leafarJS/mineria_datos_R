ggplot(aes(
week,
n
))+
geom_line()
# Componentes de ajuste
(datetime <- ymd_hms("2022-12-21 13:07:00"))
year(datetime) <- 2020
datetime
month(datetime) <- 01
datetime
hour(datetime) <- hour(datetime) + 1
datetime
# modificación total
update(
datetime,
year = 1977,
month = 2,
mday = 3,
hour = 2
)
# si nos pasamos de numero de dias en el mes
ymd("2022-02-30")
# si nos pasamos de numero de dias en el mes
ymd("2022-02-30") %>%
update(mday = 30)
# si nos pasamos de numero de dias en el mes
ymd("2022-02-01") %>%
update(mday = 30)
ymd("2022-02-01") %>%
update(hour = 400)
flights_dt %>%
mutate(dep_hour = update(dep_time, yday = 1)) %>%
view()
flights_dt %>%
mutate(dep_hour = update(dep_time, yday = 1)) %>%
ggplot(aes(
dep_hour
))+
geom_freqpoly(binwidth = 300)
# En R, cuando restas dos fechas, obtienes un objeto difftime:
h_age <- today() - ymd(19770203)
h_age
as.duration(h_age)
dseconds(15)
dminutes(55)
dhours(12)
dhours(c(1,3,6,12,24))
ddays(0:5)
dweeks(3)
dyears(1)
dyears(1)* h_age
dyears(1) * h_age
dyears(1) * 45
4 * dyears(2)
dyears(2) +  dweeks(18) + dhours(13.5)
tomorrow <- today() + ddays(4)
tomorrow
last_year <- today() - dyears(45)
last_year
one_pm <- ymd_hms("2016-03-12 13:00:00", tz = "America/New_York")
one_pm
#> [1] "2016-03-12 13:00:00 EST"
one_pm + ddays(1)
one_pm
one_pm + days(1)
seconds(15)
minutes(10)
minutes(10.18)
minutes(10)
hours(c(1,3,6,12,24))
days(7)
months(1:6)
weeks(3)
years(1)
10 * (months(6) + days(15))
10 * (months(6) + days(15)) + days(50) + hours(25) + minutes(12)
10 * (months(6) + days(15)) + days(50) + hours(25) + minutes(12) + seconds(32)
# A leap year
ymd("2016-01-01") + dyears(1)
#> [1] "2016-12-31 06:00:00 UTC"
ymd("2016-01-01") + years(1)
# Daylight Savings Time
one_pm + ddays(1)
#> [1] "2016-03-13 14:00:00 EDT"
one_pm + days(1)
flights_dt
flights_dt %>%
filter(arr_time < dep_time)
flights_dt %>%
filter(arr_time < dep_time) %>%
view()
flights_dt_1 <- flights_dt %>%
mutate(
overnight = arr_time < dep_time,
arr_time = arr_time + days(overnight * 1),
sched_arr_time = sched_arr_time + days(overnight * 1 )
) %>%
view()
flights_dt_1 %>%
filter(overnight, arr_time < dep_time)
# Intervalos
years(1) / days(1)
next_year <- today() + years(1)
next_year
(today() %--% next_year)
(today() %--% next_year) / ddays(1)
(today() %--% next_year) %/% ddays(1)
days(overnight * 1)
(today() %--% (today() + years(1))) / months(1)
(today() %--% (today() + years(1))) / months(12)
# Zonas Horarias
# zona horaria actual segun ubicación en R
Sys.timezone()
# nombres de zonas horarias
OlsonNames()
length(OlsonNames())
(x1 <- ymd_hms("2022-12-01 12:00:00", tz = "America/New_York"))
(x2 <- ymd_hms("2022-12-01 18:00:00", tz = "Europe/Copenhagen"))
(x3 <- ymd_hms("2022-12-02 04:00:00", tz = "America/Caracas"))
x1 - x2
x2 - x3
x4 <- c(x1,x2,x3)
x4
x4a <-with_tz(x4, tzone = "America/Caracas")
x4a
x4a - x4
x4b <- force_tz(x4, tzone = "Australia/Lord_Howe")
x4b
x4b - x4
library(magrittr)
theme_set(theme_minimal())
diamonds <- ggplot2::diamonds
diamonds2 <- diamonds %>%
dplyr::mutate(price_per_carat = price / carat)
pryr::object_size(diamonds)# 3.46 MB
library(magrittr)
theme_set(theme_minimal())
diamonds <- ggplot2::diamonds
diamonds2 <- diamonds %>%
dplyr::mutate(price_per_carat = price / carat)
pryr::object_size(diamonds)# 3.46 MB
pryr::object_size(diamonds2)# 3.89 MB
pryr::object_size(diamonds, diamonds2) # 3.89 MB
library(tidyverse)
library(magrittr)
theme_set(theme_minimal())
diamonds <- ggplot2::diamonds
diamonds2 <- diamonds %>%
dplyr::mutate(price_per_carat = price / carat)
pryr::object_size(diamonds)# 3.46 MB
pryr::object_size(diamonds2)# 3.89 MB
library(pryr)
install.packages("pryr")
library(tidyverse)
library(magrittr)
library(pryr)
theme_set(theme_minimal())
diamonds <- ggplot2::diamonds
diamonds2 <- diamonds %>%
dplyr::mutate(price_per_carat = price / carat)
pryr::object_size(diamonds)# 3.46 MB
pryr::object_size(diamonds2)# 3.89 MB
pryr::object_size(diamonds, diamonds2) # 3.89 MB
diamonds$carat[1] <- NA
pryr::object_size(diamonds)#  3.46 MB
pryr::object_size(diamonds2)#  3.89 MB
pryr::object_size(diamonds, diamonds2) # 4.32 MB
assign("x", 10)
x # 10
"x" %>% assign(100)
x#  10
env <- environment()
"x" %>% assign(100, envir = env)
x # 100
tryCatch(stop("!"), error = function(e) "An error")# "An error"
stop("!") %>%
tryCatch(error = function(e) "An error")# "An error"
rnorm(100) %>%
matrix(ncol = 2) %>%
plot() %>%
str()
rnorm(100) %>%
matrix(ncol = 2) %T>%
plot() %>%
str()
rnorm(100) %>%
matrix(ncol = 2) %>%
plot() %>%
str() # Error in plot.new() : figure margins too large
rnorm(100) %>%
matrix(ncol = 2) %T>%
plot() %>%
str()
library(magrittr)
rnorm(100) %>%
matrix(ncol = 2) %T>%
plot() %>%
str()
rnorm(100) %>%
matrix(ncol = 2) %T>%
plot()
rnorm(100) %>%
matrix(ncol = 2) %>%
plot() %>%
str()
mtcars %$%
cor(disp, mpg)
mtcars
mtcars <- mtcars %>%
transform(cyl = cyl * 2)
mtcars
mtcars
mtcars %<>%
transform(cyl = cyl * 8)
mtcars
library(tidyverse)
library(tidyverse)
library(tidytext)
library(ggplot2)
library(widyr)
library(lubridate)
theme_set(theme_minimal())
df <- tibble::tibble(
a = rnorm(10),
b = rnorm(10),
c = rnorm(10),
d = rnorm(10)
)
(df$a - min(df$a, na.rm = TRUE)) /
(max(df$a, na.rm = TRUE) - min(df$a, na.rm = TRUE))
x <- df$a
(x - min(x, na.rm = TRUE)) / (max(x, na.rm = TRUE) - min(x, na.rm = TRUE))
rng <- range(x, na.rm = TRUE)
(x - rng[1]) / (rng[2] - rng[1])
#mejorando el codigo
rescale01 <- function(x) {
rng <- range(x, na.rm = TRUE)
(x - rng[1]) / (rng[2] - rng[1])
}
rescale01(c(0, 5, 10))
rescale01(c(0, 5, 10))
rescale01(c(-10, 0, 10))
rescale01(c(1, 2, 3, NA, 5))
#simplificar los pasos
df$a <- rescale01(df$a)
df$b <- rescale01(df$b)
df$c <- rescale01(df$c)
df$d <- rescale01(df$d)
df$a
df$b
df$c
df$d
x <- c(1:10, Inf)
rescale01(x)
rescale01 <- function(x) {
rng <- range(x, na.rm = TRUE, finite = TRUE)
(x - rng[1]) / (rng[2] - rng[1])
}
rescale01(x)
corto_circuito <-function(x, y, op) {
switch(op,
plus = x + y,
minus = x - y,
times = x * y,
divide = x / y,
stop("Unknown op!")
)
}
corto_circuito(10,30,18)
corto_circuito <-function(x, y, op) {
switch(op,
plus = x + y,
minus = x - y,
times = x * y,
divide = x / y,
stop("Unknown op!")
)
df <- data.frame(plus, minus, times, divide)
return(df)
}
corto_circuito(10,30,18)
corto_circuito(10,30, plus)
switch(op,
plus = x + y,
minus = x - y,
times = x * y,
divide = x / y,
stop("Unknown op!")
)
corto_circuito <-function(x, y, op) {
switch(op,
plus = x + y,
minus = x - y,
times = x * y,
divide = x / y,
stop("Unknown op!")
)
}
corto_circuito(10,30, plus)
corto_circuito(10,30, "plus")
corto_circuito(10,30, "divide")
y <- 10
x <- if (y < 20) "Too low" else "Too high"
x
# Compute confidence interval around mean using normal approximation
mean_ci <- function(x, conf = 0.95) {
se <- sd(x) / sqrt(length(x))
alpha <- 1 - conf
mean(x) + se * qnorm(c(alpha / 2, 1 - alpha / 2))
}
x <- runif(100)
mean_ci(x) # 0.4976111 0.6099594
mean_ci(x, conf = 0.99) # 0.4799599 0.6276105
wt_mean <- function(x, w) {
if (length(x) != length(w)) {
stop("`x` and `w` must be the same length", call. = FALSE)
}
sum(w * x) / sum(w)
}
wt_mean(1:6, 1:3)
wt_mean(1:10, 2:11)
wt_mean <- function(x, w, na.rm = FALSE) {
stopifnot(is.logical(na.rm), length(na.rm) == 1)
stopifnot(length(x) == length(w))
if (na.rm) {
miss <- is.na(x) | is.na(w)
x <- x[!miss]
w <- w[!miss]
}
sum(w * x) / sum(w)
}
wt_mean(1:6, 6:1, na.rm = "foo")
wt_mean(1:6, 1:6, na.rm = "foo")
wt_mean(1:6, 1:6, na.rm = TRUE)
wt_mean(5:10, 5:10)
sum(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)# 55
stringr::str_c("a", "b", "c", "d", "e", "f")# "abcdef"
commas <- function(...) stringr::str_c(..., collapse = ", ")
commas(letters[1:10]) # "a, b, c, d, e, f, g, h, i, j"
rule <- function(..., pad = "-") {
title <- paste0(...)
width <- getOption("width") - nchar(title) - 5
cat(title, " ", stringr::str_dup(pad, width), "\n", sep = "")
}
rule("Important output")# Important output -------------
library(tidyverse)
typeof(letters)
typeof(1:20)
#longitud
x <- list("a", "b", 1:20)
length(x)
# logicos
1:10 %% 3 == 0
c(TRUE, FALSE, FALSE NA)
c(TRUE, FALSE, FALSE, NA)
# numérico
typeof(1)
typeof(1L)
1.5L
x <- sqrt(2) ^ 2
x
x - 2
x
c(-1,0,1) / 0
x <- c(1,2,1/8,NA)
is.infinite(x)
x <- c(1,2,1/8,NA, NaN, Inf, -Inf)
is.infinite(x)
is.finite(x)
is.na(x)
is.nan(x)
x <- "Esta es una cadena razonablemente larga"
pryr::object_size(x)
y <- rep(x, 1000)
pryr::object_size(y)
NA            # logical  NA
NA_integer_   # integer  NA
NA_real_      # double   NA
NA_character_ # character NA
x <- sample(1:10)
x
dplyr::near(x)
dplyr::near(x, 8)
x <- sample(20,100, replace = TRUE)
X
x <- sample(20,100, replace = TRUE)
x
y <- x > 10
y
sum(y)
mean(y)
typeof(c(TRUE, 1L))
typeof(c(1L,1.5))
typeof(c(1.5, "a"))
x <- c(1,2,3,"a", NA, NaN, 1.5, 8L, -Inf, Inf, NULL)
is_logical(x)
is_integer(x)
x <- c(1,2,3,"a", NA, NaN, 1.5, 8L, -Inf, Inf, NULL)
is_logical(x)
is_integer(x)
is_double(x)
is_numeric(x)
is_character(x)
is_atomic(x)
is_list(x)
is_vector(x)
sample(10) + 100
runif(10) > 5
runif(10) > 0.5
1:10 + 1:2
1:10 + 1:3
tibble(x = 1:4, y = 1:2)
tibble(x = 1:4, y = rep(1:2, 2))
tibble(x = 1:4, y = rep(1:2, each = 2))
c(x = 1, y = 2, z = 3)
purrr::set_names(1:3, c("a", "b", "c"))
x <- c("one", "two", "three", "four", "five")
x[c(3,2,5)]
x[c(1,1,5,5,5,2,4)]
c[c(-1,-5)]
x[c(-1,-5)]
x[c(1,-1)]
x[0]
x <- c(10, 3, NA, 5, 8, 1, NA)
x <- c(10, 3, NA, 5, 8, 1, NA)
x[!is.na(x)]
x[x %% 2 == 0]
x <- c(abc = 1, def = 2, xyz = 5)
x[c("xyz", "def")]
# vectores recursivos
x <- list(1,2,3)
x
str(x)
x <- list(a= 1, b = 2, c = 3)
str(x)
x <- list("a", 1L, 1.5, TRUE)
str(x)
x <- list(list(1, 2, "a", FALSE), list(3, 4, -Inf))
str(x)
# visualización de listas
x <- list(c(1,2), c(3,4))
y <- list(list(1,2), list(3,4))
z <- list(1, list(2, list(3)))
# creacion de subconjuntos
x <- list(a = 1:3, b = "a string", c = pi, d = list(-1, -5))
str(x[1:2])
str(x[4])
str(x[[1]])
str(x[[4]])
x$a
x$d
x$d[1]
x$d
x$d[1]
# atributos
x <- 1:10
attr(x)
attr(x, "greeting")
attr(x, "greeting") <- "Hi!"
attr(x, "greeting") <- "Bye!"
attributes(x)
attr(x, "greeting") <- "Hi!"
attr(x, "greeting") <- "Bye!"
attributes(x)
attr(x, "greeting") <- "Hi!"
attr(x, "farewell") <- "Bye!"
attributes(x)
# Así es como se ve una función genérica típica:
as.Date()
# Así es como se ve una función genérica típica:
as.Date
methods("as.Date")
getS3method("as.Date", "default")
getS3method("as.Date", "default")
getS3method("as.Date", "numeric")
# factores
x <- factor(c("ab", "cd", "ab"), levels = c("ab", "cd", "ef"))
x
typeof(x)
attributes(x)
# fechas y fechas-horas
x <- as.Date("1977-02-03")
unclass(x)
typeof(x)
attributes(x)
x <- lubridate::ymd_hm("1970-01-01 01:00")
unclass(x)
attr(, "tzone")
attr(x, "tzone")
typeof(x)
attributes(x)
attr(x, "tzone") <- "US/Pacific"
x
attr(x, "tzone") <- "US/Eastern"
x
y <- as.POSIXlt(x)
y
typeof(y)
attributes(y)
x <- tibble::tibble(x = 1:5, y = 5:1)
x
typeof(x)
attributes(x)
x <- tibble::tibble(x = 1:5, y = 5:1)
x
typeof(x)
attributes(x)
x <- data.frame(x = 1:5, y = 5:1)
x
typeof(x)
attributes(x)
